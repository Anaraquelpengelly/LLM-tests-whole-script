/* * SPDX-FileCopyrightText: Copyright Â© 2018 WebGoat authors * SPDX-License-Identifier: GPL-2.0-or-later */package org.owasp.webgoat.lessons.sqlinjection.introduction;import static org.hsqldb.jdbc.JDBCResultSet.CONCUR_UPDATABLE;import static org.hsqldb.jdbc.JDBCResultSet.TYPE_SCROLL_SENSITIVE;import static org.owasp.webgoat.container.assignments.AttackResultBuilder.failed;import static org.owasp.webgoat.container.assignments.AttackResultBuilder.success;import java.sql.Connection;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;import java.sql.Statement;import org.owasp.webgoat.container.LessonDataSource;import org.owasp.webgoat.container.assignments.AssignmentEndpoint;import org.owasp.webgoat.container.assignments.AssignmentHints;import org.owasp.webgoat.container.assignments.AttackResult;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.bind.annotation.RestController;@RestController@AssignmentHints(    value = {      "SqlStringInjectionHint.9.1",      "SqlStringInjectionHint.9.2",      "SqlStringInjectionHint.9.3",      "SqlStringInjectionHint.9.4",      "SqlStringInjectionHint.9.5"    })public class SqlInjectionLesson9 implements AssignmentEndpoint {  private final LessonDataSource dataSource;  public SqlInjectionLesson9(LessonDataSource dataSource) {    this.dataSource = dataSource;  }  @PostMapping("/SqlInjection/attack9")  @ResponseBody  public AttackResult completed(@RequestParam String name, @RequestParam String auth_tan) {    return injectableQueryIntegrity(name, auth_tan);  }  protected AttackResult injectableQueryIntegrity(String name, String auth_tan) {    StringBuilder output = new StringBuilder();    String queryInjection = "SELECT * FROM employees WHERE last_name = ? AND auth_tan = ?";    try (Connection connection = dataSource.getConnection()) {      // V2019_09_26_7__employees.sql      int oldMaxSalary = this.getMaxSalary(connection);      int oldSumSalariesOfOtherEmployees = this.getSumSalariesOfOtherEmployees(connection);      // begin transaction      connection.setAutoCommit(false);      // do injectable query      PreparedStatement statement = connection.prepareStatement(queryInjection, TYPE_SCROLL_SENSITIVE, CONCUR_UPDATABLE);      statement.setString(1, name);      statement.setString(2, auth_tan);      SqlInjectionLesson8.log(connection, queryInjection);      statement.execute();      // check new sum of salaries other employees and new salaries of John      int newJohnSalary = this.getJohnSalary(connection);      int newSumSalariesOfOtherEmployees = this.getSumSalariesOfOtherEmployees(connection);      if (newJohnSalary > oldMaxSalary          && newSumSalariesOfOtherEmployees == oldSumSalariesOfOtherEmployees) {        // success commit        connection.commit(); // need execute not executeQuery        connection.setAutoCommit(true);        output.append(            SqlInjectionLesson8.generateTable(this.getEmployeesDataOrderBySalaryDesc(connection)));        return success(this).feedback("sql-injection.9.success").output(output.toString()).build();      }      // failed roolback      connection.rollback();      return failed(this)          .feedback("sql-injection.9.one")          .output(              SqlInjectionLesson8.generateTable(this.getEmployeesDataOrderBySalaryDesc(connection)))          .build();    } catch